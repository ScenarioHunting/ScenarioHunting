/**
 * Custom JSX module designed specifically for TypeDoc's needs.
 * When overriding a default TypeDoc theme output, your implementation must create valid {@link Element}
 * instances, which can be most easily done by using TypeDoc's JSX implementation. To use it, set up
 * your tsconfig with the following compiler options:
 * ```json
 * {
 *     "jsx": "react",
 *     "jsxFactory": "JSX.createElement",
 *     "jsxFragmentFactory": "JSX.Fragment",
 *     "jsxImportSource": "typedoc"
 * }
 * ```
 * @module
 */
/// <reference lib="dom" />
import type { KeysOfType, WritableKeys } from "./general";
export declare const Fragment: unique symbol;
/**
 * Used to inject HTML directly into the document.
 */
export declare function Raw(_props: {
    html: string;
}): null;
export declare type Children = Element | string | number | null | undefined | Children[];
export declare type Component<P> = (props: P) => Element | null | undefined;
declare type BannedElementKeys = "dataset" | "innerHTML" | "outerHTML" | "innerHTML" | "innerText" | "textContent" | "style";
interface RemapKeys {
    className: "class";
    htmlFor: "for";
    httpEquiv: "http-equiv";
}
declare type ElementKeys<T> = Exclude<WritableKeys<T>, BannedElementKeys | KeysOfType<T, Function>>;
declare type BasicHtmlElements = {
    [K in keyof HTMLElementTagNameMap]: {
        [K2 in ElementKeys<HTMLElementTagNameMap[K]> as K2 extends keyof RemapKeys ? RemapKeys[K2] : K2]?: K2 extends "children" ? Children : HTMLElementTagNameMap[K][K2];
    } & {
        style?: string;
    } & (K extends "meta" ? {
        charSet?: string;
    } : unknown);
};
/** @hidden */
export interface IntrinsicElements extends BasicHtmlElements {
}
export interface Element {
    tag: typeof Fragment | string | Component<any>;
    props: object | null;
    children: Children[];
}
/**
 * TypeScript's rules for looking up the JSX.IntrinsicElements and JSX.Element
 * interfaces are incredibly strange. It will find them if they are included as
 * a namespace under the createElement function, or globally, or, apparently, if
 * a JSX namespace is declared at the same scope as the factory function.
 * Hide this in the docs, hopefully someday TypeScript improves this and allows
 * looking adjacent to the factory function and we can get rid of this phantom namespace.
 * @hidden
 */
export declare namespace JSX {
    export { IntrinsicElements, Element };
}
/**
 * JSX factory function to create an "element" that can later be rendered with {@link renderElement}
 * @param tag
 * @param props
 * @param children
 */
export declare function createElement(tag: typeof Fragment | string | Component<any>, props: object | null, ...children: Children[]): Element;
export declare function renderElement(element: Element | null | undefined): string;
export {};
