/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/board.ts":
/*!**********************!*\
  !*** ./src/board.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Board\": () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _test_factory_board_data_mapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./test-factory/board-data-mapper */ \"./src/test-factory/board-data-mapper.tsx\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable no-undef */\n\nclass Board {\n    constructor() {\n        this.unselectAll = () => __awaiter(this, void 0, void 0, function* () {\n            if (!miro || !miro.board)\n                yield new Promise(resolve => setTimeout(resolve, 200));\n            yield miro.board.selection.clear();\n        });\n        this.showNotification = (message) => miro.showNotification(message);\n        this.zoomTo = (widget) => miro.board.viewport.zoomToObject(widget.id, true);\n        // static async captureSingleItemSelections(widgets, succeed, fail) {\n        //     // miro.board.widgets.sel\n        // }\n    }\n    openModal(modalAddress) {\n        miro.board.ui.openModal(modalAddress, { width: 50, height: 50 });\n        throw new Error(\"Method not implemented.\");\n    }\n    // eslint-disable-next-line no-unused-vars\n    onWidgetLeft(updateText) {\n        const select = (selections) => __awaiter(this, void 0, void 0, function* () {\n            var widgets = selections.data;\n            if (!this.previouslySelectedWidgets)\n                this.previouslySelectedWidgets = widgets;\n            this.previouslySelectedWidgets.forEach(item => updateText(item.id));\n            this.previouslySelectedWidgets = widgets;\n        });\n        miro.addListener(\"SELECTION_UPDATED\", select);\n    }\n    // eslint-disable-next-line no-unused-vars\n    interceptPossibleTextEdit(updateText) {\n        const select = (selections) => __awaiter(this, void 0, void 0, function* () {\n            var widgets = selections.data;\n            if (!this.previouslySelectedWidgets) {\n                this.previouslySelectedWidgets = widgets;\n            }\n            this.previouslySelectedWidgets.forEach((item) => __awaiter(this, void 0, void 0, function* () {\n                let widget = (yield miro.board.widgets.get({ id: item.id }))[0];\n                const originalWidgetText = yield getWidgetText(widget);\n                const newText = yield updateText(widget.id, originalWidgetText);\n                widget = yield setWidgetText(widget, newText);\n                if (newText != originalWidgetText)\n                    yield miro.board.widgets.update([widget]);\n            }));\n            this.previouslySelectedWidgets = widgets;\n        });\n        miro.addListener(\"SELECTION_UPDATED\", select);\n    }\n    // eslint-disable-next-line no-unused-vars\n    getWidgetText(widgetId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"Finding widget by id:\" + widgetId);\n            var widget = (yield miro.board.widgets.get({ id: widgetId }))[0];\n            return yield getWidgetText(widget);\n        });\n    }\n    updateWidgetText(widgetId, newWidgetText) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let widget = (yield miro.board.widgets.get({ id: widgetId }))[0];\n            widget = yield setWidgetText(widget, newWidgetText);\n            yield miro.board.widgets.update([widget]);\n        });\n    }\n    // eslint-disable-next-line no-unused-vars\n    onNextSingleSelection(succeed) {\n        //TODO: Guard \n        console.log(\"Waiting for the next single selection!\");\n        const select = (selections) => __awaiter(this, void 0, void 0, function* () {\n            var widgets = selections.data;\n            if (widgets.length == 0)\n                return;\n            console.log(\"Selected.\");\n            if (widgets.length > 1) {\n                console.log(`${widgets.length} items are selected. Only a single one can be selected.`);\n                return;\n            }\n            console.log(\"Getting the widget.\");\n            var widget = (yield miro.board.widgets.get({ id: widgets[0].id }))[0];\n            console.log(\"Converting the widget\");\n            convertToDto(widget)\n                .then(dto => {\n                // if (typeof dto == 'string')\n                //     console.log(dto)\n                // else {\n                console.log(dto);\n                succeed(dto);\n                miro.removeListener(\"SELECTION_UPDATED\", select);\n                // }\n            })\n                .catch(console.log);\n        });\n        return miro.addListener(\"SELECTION_UPDATED\", select);\n    }\n}\nfunction getTheStartingWidget(arrow) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const all = yield miro.board.widgets.get({ id: arrow.startWidgetId });\n        if (all.length == 0)\n            yield miro.showNotification(\"Examples should be connected to a fact they belong to.\");\n        return all[0];\n    });\n}\nfunction getIncomingArrows(exampleWidget) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (yield (yield miro.board.widgets.get({ type: \"LINE\", endWidgetId: exampleWidget.id }))\n            .map(line => line))\n            .filter(line => line.style.lineEndStyle != 0);\n    });\n}\nfunction getAbstractionWidgetFor(exampleWidget) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const incomingArrows = yield getIncomingArrows(exampleWidget);\n        if (incomingArrows.length === 0)\n            return Promise.resolve(exampleWidget);\n        const widgetsPointingToThis = yield Promise.all(incomingArrows.map(getTheStartingWidget));\n        if (widgetsPointingToThis.length > 1) {\n            const errorMessage = \"Examples can not belong to more than one abstraction (only one incoming line).\";\n            yield miro.showNotification(errorMessage);\n            return Promise.reject(errorMessage);\n        }\n        return Promise.resolve(widgetsPointingToThis[0]);\n    });\n}\nfunction getWidgetStyle(widget) {\n    const style = {};\n    if (widget[\"style\"] && widget[\"style\"][\"backgroundColor\"]) {\n        console.log('Setting style:', widget[\"style\"][\"backgroundColor\"]);\n        style.backgroundColor = widget[\"style\"][\"backgroundColor\"];\n    }\n    else if (widget[\"style\"] && widget[\"style\"][\"stickerBackgroundColor\"]) {\n        console.log('Setting style:', widget[\"style\"][\"stickerBackgroundColor\"]);\n        style.backgroundColor = widget[\"style\"][\"stickerBackgroundColor\"];\n    }\n    return style;\n}\nfunction convertToDto(widget) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var dto = {\n            id: widget.id,\n            // type: widget.type,\n            exampleWidget: widget,\n        };\n        dto.abstractionWidget = yield getAbstractionWidgetFor(dto.exampleWidget);\n        //\n        console.log('Selection dto initiated.', dto);\n        dto.style = getWidgetStyle(widget);\n        try {\n            const purifyWidgetText = (originalText) => originalText.split('</p><p>').join('\\n')\n                .replace('<p>', '')\n                .replace('</p>', '')\n                .replace('&#43;', '+');\n            dto.exampleText = purifyWidgetText(yield getWidgetText(widget));\n        }\n        catch (e) {\n            return Promise.reject('The widget ' + JSON.stringify(widget) + ' does not have any text.');\n        }\n        console.log('Widget text converted by board.:', dto.exampleText);\n        try {\n            var data = yield (0,_test_factory_board_data_mapper__WEBPACK_IMPORTED_MODULE_0__.convertWidgetToStepData)(dto.exampleText);\n            const step = {\n                widgetSnapshot: dto,\n                widgetData: data\n            };\n            return step;\n        }\n        catch (e) {\n            miro.showNotification(e);\n            return Promise.reject(e);\n        }\n    });\n}\nfunction getWidgetText(widget) {\n    if (!widget)\n        return Promise.reject(\"Cannot get the widget text. The widget is undefined.\");\n    if (\"text\" in widget)\n        return widget[\"text\"];\n    if (\"captions\" in widget\n        && widget[\"captions\"]\n        && widget[\"captions\"][0]\n        && widget[\"captions\"][0][\"text\"])\n        return Promise.resolve(widget[\"captions\"][0][\"text\"]);\n    return Promise.reject(\"Cannot get the widget text. The widget has no text fields.\");\n}\nfunction setWidgetText(widget, text) {\n    const anyWidget = widget;\n    if (\"text\" in widget)\n        anyWidget[\"text\"] = text;\n    else if (\"captions\" in widget)\n        anyWidget[\"captions\"][0][\"text\"] = text;\n    else\n        return Promise.reject(\"Cannot set the widget text. The widget has no text fields.\");\n    return Promise.resolve(anyWidget);\n}\n\n\n//# sourceURL=webpack://plugin-boilerplate/./src/board.ts?");

/***/ }),

/***/ "./src/global-dependency-container.ts":
/*!********************************************!*\
  !*** ./src/global-dependency-container.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"singletonBoard\": () => (/* binding */ singletonBoard),\n/* harmony export */   \"testResultReports\": () => (/* binding */ testResultReports)\n/* harmony export */ });\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.ts\");\n/* harmony import */ var _test_result_reports__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./test-result-reports */ \"./src/test-result-reports.ts\");\n\n\nlet singletonBoard = new _board__WEBPACK_IMPORTED_MODULE_0__.Board();\nlet testResultReports = new _test_result_reports__WEBPACK_IMPORTED_MODULE_1__.TestResultReports();\n\n\n//# sourceURL=webpack://plugin-boilerplate/./src/global-dependency-container.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_dependency_container__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./global-dependency-container */ \"./src/global-dependency-container.ts\");\n/* harmony import */ var _test_result_reports__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./test-result-reports */ \"./src/test-result-reports.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/* eslint-disable no-undef */\n// const icon24 = `<svg height=\"12\" width=\"12\">\n// <text x=\"0\" y=\"12\" fill=\"currentColor\">T</text>\n// T\n// </svg>`\n//https://yqnn.github.io/svg-path-editor/\n// const iconT = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M 20.156 7.762 M 6.738 11.547 L 6.855 19.217 L 10.981 18.944 L 11.008 10.835 z z L 0.431 12.559 L 0.243 2.117 L 16.12 4.587 L 16 10 Z L 12.012 9.966 l 0.018 -2.53 l -3.073 -0.241 L 8.978 10.158 L 12.072 9.716 L 12.818 9.038 L 15.002 8.723 L 15.002 7.445 L 13.117 7.269 L 13.137 9.956 Z L 6.889 5.546 L 2.071 5.032 L 2.039 9.377 L 6.802 8.95\"/>'\n// const iconT = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M 20.156 7.762 M 6.976 11.406 L 11 11 L 11 20 L 16.818 19.413 L 16.624 9.99 z z L 0.431 12.559 L 0.243 2.117 L 22.191 5.189 L 22.191 9.166 Z L 13.384 9.71 l -0.103 -3.31 l -4.511 -0.231 L 8.943 9.813 L 14.207 8.945 L 18.208 8.227 L 18.208 6.299 L 15.433 5.987 L 15.433 9.403 Z L 7.03 5.075 L 1.642 4.591 L 1.642 8.708 L 8.487 8.187\"/>'\n// const iconT = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M 20.156 7.762 M 6.976 11.406 L 8.665 11.281 L 8.731 19.388 L 16.818 19.413 L 16.687 10.002 z z L 0.431 12.559 L 0.243 2.117 L 22.191 5.189 L 22.191 9.166 Z L 13.384 9.71 l -0.103 -3.31 l -4.511 -0.231 L 8.943 9.813 L 14.207 8.945 L 18.208 8.227 L 18.208 6.299 L 15.433 5.987 L 15.433 9.403 Z L 7.03 5.075 L 1.642 4.591 L 1.642 8.708 L 8.487 8.187\"/>'\nconst iconT = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M 20.156 7.762 M 6.738 11.547 L 6.414 21.703 L 11.954 19.53 L 12.005 10.678 z z L 0.431 12.559 L 0.243 2.117 L 16.12 4.587 L 16 10 Z L 12.012 9.966 l 0.018 -2.53 l -3.073 -0.241 L 8.978 10.158 L 12.072 9.716 L 12.818 9.038 L 15.002 8.723 L 15.002 7.445 L 13.117 7.269 L 13.137 9.956 Z L 6.889 5.546 L 2.071 5.032 L 2.039 9.377 L 6.802 8.95\"/>';\n// const icon24 = '<path fill=\"currentColor\" fill-rule=\"nonzero\" d=\"M 20.156 7.762 c -1.351 -3.746 -4.672 -5.297 -8.838 -4.61 c -3.9 0.642 -7.284 3.15 -7.9 5.736 c -1.14 4.784 -0.015 7.031 2.627 8.09 c 0.61 0.244 1.28 0.412 2.002 0.518 c 0.277 0.041 0.549 0.072 0.844 0.097 c 0.138 0.012 0.576 0.045 0.659 0.053 c 0.109 0.01 0.198 0.02 0.291 0.035 c 1.609 0.263 2.664 1.334 3.146 2.715 c 7.24 -2.435 9.4 -6.453 7.17 -12.634 z m -18.684 0.662 C 3.18 1.256 18.297 -3.284 22.038 7.084 c 2.806 7.78 -0.526 13.011 -9.998 15.695 c -0.266 0.076 -0.78 0.173 -0.759 -0.287 c 0.062 -1.296 -0.47 -2.626 -1.762 -2.837 c -1.009 -0.165 -10.75 0.124 -8.047 -11.23 M 11.567 11.256 c -0.129 1.808 -0.185 2.653 -0.25 3.86 l 2.267 -0.131 c 0.05 -0.913 0.093 -1.617 0.189 -4.349 z z L 9.155 12.152 L 9.155 5.742 L 16 7 L 16 10 Z L 12.05 9.74 l 0 -1.447 l -2.068 -0.138 L 10.051 10.498 L 12.05 9.878 L 12.808 9.119 L 14.738 8.775 L 14.738 7.534 L 13.428 7.396 L 13.428 9.119 Z\"/>'\nconst underlineIcon = '<line x1=\"22\" y1=\"22\" x2=\"00\" y2=\"22\" stroke=\"currentColor\" stroke-width=\"2\"></line>';\n// async function makeAnExample(sourceWidget: SDK.IWidget) { // accept widgets as parameter, work on te\n// \t// const selectedWidgets  = await miro.board.selection.get()\n// \t// if (widgets.length != 1)\n// \t// \treturn\n// \t// const sourceWidget = widgets[0]\n// \tconsole.log(\"SOURCE!!!!!!!!!!!!!!\", sourceWidget)\n// \tconst exampleWidget = await miro.board.widgets.create({ type: sourceWidget.type, bounds: { x: sourceWidget.bounds.x, y: sourceWidget.bounds.y } });\n// \tconsole.log(\"EXAMPLE!!!!!!!!!!!!!!\", exampleWidget)\n// \t// //let result = await miro.board.selection.get();\n// \t// let result = widgets;\n// \t// var textEdit = (await miro.board.widgets.get({ id: result[0].id }))[0]['text'];\n// \t// // if (textEdit.includes(\"<u>\")) {\n// \t// textEdit = textEdit.replace(\"<u>\", \"\").replace(\"</u>\", \"\");\n// \t// // } else {\n// \t// // textEdit = textEdit \n// \t// // textEdit = \"<input type='text' placeholder='\" + textEdit + \"'></input>\"\n// \t// // }\n// \t// miro.board.widgets.update({\n// \t// \tid: result[0]['id'],\n// \t// \ttext: textEdit\n// \t// })\n// }\nconst attachReportToWidgetByWidgetId = (widgetId, theOriginalText) => __awaiter(void 0, void 0, void 0, function* () {\n    var vm = yield _global_dependency_container__WEBPACK_IMPORTED_MODULE_0__.testResultReports.getTestSummeryForWidget(widgetId);\n    if (typeof vm == 'boolean')\n        return theOriginalText;\n    return attachReportToWidgetText(vm, theOriginalText);\n});\nconst attachReportToWidgetText = (vm, theOriginalText) => {\n    const cleanLastReport = (textIncludingReport) => {\n        var regex = new RegExp(\"<div data-section='test-summery'>.*</div>\");\n        const widgetAlreadyContainsAReport = regex.test(textIncludingReport);\n        if (widgetAlreadyContainsAReport)\n            textIncludingReport = textIncludingReport.replace(regex, \"\");\n        textIncludingReport = textIncludingReport\n            .replace(new RegExp(\"Failing[(]\\\\d+/\\\\d+[)]\"), \"\")\n            .replace(new RegExp(\"Passing[(]\\\\d+/\\\\d+[)]\"), \"\")\n            .replace(new RegExp(\"Skipping[(]\\\\d+/\\\\d+[)]\"), \"\")\n            .replace(new RegExp(\"Pending[(]\\\\d+/\\\\d+[)]\"), \"\")\n            .replace(new RegExp(`<div><span style=\"background-color:#de2f2f;color:#fff\"> &nbsp;</span><span style=\"background-color:#1fab0f;color:#eff\"> &nbsp;</span><span style=\"background-color:#f1c807;color:#046\"> &nbsp;</span><span style=\"background-color:#199;color:#fff\"> &nbsp;</span></div>`), \"\")\n            .replace(new RegExp(`<span style=\"background-color:.+>.+</span>`), \"\");\n        // \"<div><span style=\"background-color:#de2f2f;color:#fff\">  </span><span style=\"background-color:#1fab0f;color:#eff\">  </span><span style=\"background-color:#f1c807;color:#046\">  </span><span style=\"background-color:#199;color:#fff\">  </span></div><div><span style=\"background-color:#de2f2f;color:#fff\">  </span><span style=\"background-color:#1fab0f;color:#eff\">  </span><span style=\"background-color:#f1c807;color:#046\">  </span><span style=\"background-color:#199;color:#fff\">  </span></div><div data-section='test-summery'><span style='background-color:#de2f2f;color:#fff'> Failing(0/1) </span><span style='background-color:#1fab0f;color:#eff'> Passing(1/1) </span><span style='background-color:#f1c807;color:#046'> Skipping(0/1) </span><span style='background-color:#199;color:#fff'> Pending(0/1) </span></div>\"\n        return textIncludingReport;\n    };\n    theOriginalText = cleanLastReport(theOriginalText);\n    var reportComponent = \"<div data-section='test-summery'>\" +\n        \"<span style='background-color:#de2f2f;color:#fff'> Failing(\" + vm.failed + \"/\" + vm.total + \") </span>\" +\n        \"<span style='background-color:#1fab0f;color:#eff'> Passing(\" + vm.passed + \"/\" + vm.total + \") </span>\" +\n        \"<span style='background-color:#f1c807;color:#046'> Skipping(\" + vm.skipped + \"/\" + vm.total + \") </span>\" +\n        \"<span style='background-color:#199;color:#fff'> Pending(\" + vm.pending + \"/\" + vm.total + \") </span>\" +\n        \"</div>\";\n    return theOriginalText + reportComponent;\n};\nconst applyReportToWidget = (widgetId, vm) => __awaiter(void 0, void 0, void 0, function* () {\n    const originalWidgetText = yield _global_dependency_container__WEBPACK_IMPORTED_MODULE_0__.singletonBoard.getWidgetText(widgetId);\n    const newWidgetText = attachReportToWidgetText(vm, originalWidgetText);\n    yield _global_dependency_container__WEBPACK_IMPORTED_MODULE_0__.singletonBoard.updateWidgetText(widgetId, newWidgetText);\n});\nlet generateBoardSection = (content) => {\n    console.log(\"GeneratingBoardBasedOn:\", content);\n};\nlet subscribeToServerEvents = (webSocketUrl) => {\n    let ws = new WebSocket(webSocketUrl);\n    function connect() {\n        var reconnectionTimer = setInterval(() => {\n            try {\n                ws = new WebSocket(webSocketUrl);\n                clearInterval(reconnectionTimer);\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }, 1000);\n    }\n    ws.onopen = function () {\n        console.log(\"Websocket connection opened\");\n    };\n    ws.onclose = function () {\n        console.log(\"Web socket closed, trying to reconnect.\");\n        connect();\n        // ws = null;\n    };\n    ws.onmessage = function (evt) {\n        if (evt.data && evt.data.messageType == \"BoardSectionGenerated\") {\n            var content = evt.data.content;\n            generateBoardSection(content);\n        }\n        console.log(\"Summery: \" + evt.data);\n        var message = JSON.parse(evt.data);\n        const summery = (0,_test_result_reports__WEBPACK_IMPORTED_MODULE_1__.TestReportToSummery)(message.testReport);\n        console.log(\"Summery: \" + JSON.stringify(summery));\n        applyReportToWidget(message.id, summery).catch(console.log);\n        // const widget = miro.board.widgets.get({ id: evt.data.id })\n    };\n    ws.onerror = function (evt) {\n        console.log(\"ERROR: \" + evt);\n        connect();\n    };\n};\nmiro.onReady(() => __awaiter(void 0, void 0, void 0, function* () {\n    // console.log(\"Client Id:\", miro.getClientId())3074457349056199734\n    yield _global_dependency_container__WEBPACK_IMPORTED_MODULE_0__.singletonBoard.interceptPossibleTextEdit(attachReportToWidgetByWidgetId);\n    yield miro.initialize({\n        extensionPoints: {\n            getWidgetMenuItems: (widgets /*, editMode: boolean*/) => {\n                const supportedWidgetsInSelection = widgets;\n                // .filter((widget) => Config.supported_widgets[widget.type.toLowerCase()] \n                // \t\t\t\t\t\t\t\t\t!== undefined);\n                // All selected widgets have to be supported in order to show the menu\n                if (supportedWidgetsInSelection.length == widgets.length && widgets.length == 1) {\n                    return Promise.resolve([{\n                            tooltip: 'Make an Example',\n                            svgIcon: underlineIcon,\n                            onClick: () => {\n                                // miro.board.ui.openLeftSidebar('sidebar.html')\n                                // makeAnExample(widgets[0])\n                                // handleAuthAndOpenWindow(openEstimateModal, widgets);\n                            }\n                        }]);\n                }\n                // Not all selected widgets are supported, we won't show the menu\n                return Promise.resolve([{}]);\n            },\n            // exportMenu: {\n            // \ttitle: 'Boilerplate export',\n            // \tsvgIcon: icon24,\n            // \tonClick: () => {\n            // \t\t// Remember that 'modal.html' resolves relative to main.js file. So modal.html have to be in the /dist/ folder.\n            // \t\tmiro.board.ui.openModal('modal.html')\n            // \t}\n            // },\n            bottomBar: {\n                title: 'Context Reflective Test',\n                svgIcon: iconT,\n                onClick: () => {\n                    miro.board.ui.openLeftSidebar('sidebar.html');\n                }\n            }\n        }\n    });\n    subscribeToServerEvents(\"ws://localhost:8080/ws\");\n}));\n\n\n//# sourceURL=webpack://plugin-boilerplate/./src/index.ts?");

/***/ }),

/***/ "./src/test-factory/board-data-mapper.tsx":
/*!************************************************!*\
  !*** ./src/test-factory/board-data-mapper.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertWidgetToStepData\": () => (/* binding */ convertWidgetToStepData)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction convertWidgetToStepData(exampleWidgetText\n// // eslint-disable-next-line no-unused-vars\n// , succeed: (data: StepData) => void\n// eslint-disable-next-line no-unused-vars\n) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const chunks = exampleWidgetText.split('\\n');\n        let type = chunks.shift();\n        if (!type) {\n            return Promise.reject(\"Unknown text format.\");\n        }\n        // const value = chunks\n        const toCamelCase = (str) => str.trim() //.toLowerCase()\n            .replace(/([^A-Z0-9]+)(.)/ig, function () {\n            return arguments[2].toUpperCase();\n        });\n        type = toCamelCase(type);\n        const convert = (p) => {\n            return { propertyName: toCamelCase(p[0]), simplePropertyValue: p[1].trim() };\n        };\n        const example = chunks\n            .map(p => p.split(\":\"))\n            .map(convert);\n        // const example = Object.fromEntries(value)\n        // succeed({ type, properties: example })\n        return Promise.resolve({ type, properties: example });\n    });\n}\n\n\n//# sourceURL=webpack://plugin-boilerplate/./src/test-factory/board-data-mapper.tsx?");

/***/ }),

/***/ "./src/test-result-reports.ts":
/*!************************************!*\
  !*** ./src/test-result-reports.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WhenTestResultsSummeryViewModel\": () => (/* binding */ WhenTestResultsSummeryViewModel),\n/* harmony export */   \"WhenTestReportViewModel\": () => (/* binding */ WhenTestReportViewModel),\n/* harmony export */   \"TestResultReports\": () => (/* binding */ TestResultReports),\n/* harmony export */   \"TestReportToSummery\": () => (/* binding */ TestReportToSummery)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable no-undef */\nclass WhenTestResultsSummeryViewModel {\n}\nclass WhenTestReportViewModel {\n}\nclass TestResultReports {\n    constructor() {\n        this.getTestSummeryForWidget = (widgetId) => __awaiter(this, void 0, void 0, function* () {\n            const widget = (yield miro.board.widgets.get({ id: widgetId }))[0];\n            if (!widget\n                || !widget.metadata[miro.getClientId()]\n                || !widget.metadata[miro.getClientId()].testReport\n                || !widget.metadata[miro.getClientId()].testReport) {\n                return false;\n            }\n            const report = widget.metadata[miro.getClientId()].testReport;\n            // const result: WhenTestResultsSummeryViewModel = {\n            //     total: (report.passed ?? []).length + (report.failed ?? []).length + (report.pending ?? []).length + (report.skipped ?? []).length,\n            //     passed: (report.passed ?? []).length,\n            //     failed: (report.failed ?? []).length,\n            //     skipped: (report.skipped ?? []).length,\n            //     pending: (report.pending ?? []).length,\n            //     // example: widget.metadata[miro.getClientId()].testSummery.example\n            // }\n            return TestReportToSummery(report);\n            // if (!widget\n            //     || !widget.metadata[miro.getClientId()]\n            //     || !widget.metadata[miro.getClientId()].testReport\n            //     || !(widget.metadata[miro.getClientId()].testReport as WhenTestReportViewModel)\n            //     || !((widget.metadata[miro.getClientId()].testReport as WhenTestReportViewModel).summery)) {\n            //     return false\n            // }\n            // return widget.metadata[miro.getClientId()].testSummery as WhenTestResultsSummeryViewModel\n        });\n    }\n}\nfunction TestReportToSummery(report) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const result = {\n        total: ((_a = report.passed) !== null && _a !== void 0 ? _a : []).length + ((_b = report.failed) !== null && _b !== void 0 ? _b : []).length + ((_c = report.pending) !== null && _c !== void 0 ? _c : []).length + ((_d = report.skipped) !== null && _d !== void 0 ? _d : []).length,\n        passed: ((_e = report.passed) !== null && _e !== void 0 ? _e : []).length,\n        failed: ((_f = report.failed) !== null && _f !== void 0 ? _f : []).length,\n        skipped: ((_g = report.skipped) !== null && _g !== void 0 ? _g : []).length,\n        pending: ((_h = report.pending) !== null && _h !== void 0 ? _h : []).length,\n        // example: widget.metadata[miro.getClientId()].testSummery.example\n    };\n    return result;\n}\n\n\n//# sourceURL=webpack://plugin-boilerplate/./src/test-result-reports.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;